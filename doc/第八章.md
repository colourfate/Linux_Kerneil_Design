## 进程间通信

#### 1. 管道机制
 - 管道文件的创建过程

```cpp
//创建管道实例
#include <stdio.h>
#include <unistd.h>

int main()
{
    int n, fd[2];
    pid_t pid;
    int i, j;
    char str1[1024];
    char str2[512];
    
    for(i=0; i<1024; i++){
        str1[i]='A';
    }
    if(pipe(fd) < 0){
        printf("pipe error\n");
        return -1;
    }
    if(pid = fork() < 0){
        printf("fork error\n");
        return -1;
    }else if(pid > 0){  // 父进程写数据
        close(fd[0]);
        for(i=0; i<10000; i++){
            write(fd[1], str1, strlen(str1));
        }
    }else{              // 子进程读数据
        close(fd[1]);
        for(i=0; i<20000; i++){
            read(fd[0], str2, strlen(str2));
        }
    }
    
    return 0;
}
``` 

```cpp
 fs --- pipe.c --- sys_pipe() --- 在file_table[64]中申请两个空闲项
     |                         |  分别为f[0]和f[1]
     |                         |- 在current的filp[20]中找到两个空闲项
     |                         |  filp[fd[0]]和filp[fd[1]]，分别指向
     |                         |  f[0]和f[1]
     |                         |- inode=get_pipe_inode()
     |                         |- f[0]->f_inode = f[1]->f_inode = inode
     |                         |  //指向同一个indoe
     |                         |- f[0]->f_mode = 1//读
     |                         |- f[1]->f_mode = 2//写
     |
     |- inode.c --- get_pipe_inode() --- inode = get_empty_inode()
                                      |- inode->i_size=get_free_page()
                                      |- inode->i_count = 2
                                      |- PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0
                                      |- inode->i_pipe = 1
```

#### 管道的操作

 - 假设首先进行读进程，此时管道中还没有数据，size=0, 读进程会被挂起，切换到写进程中执行
 - 写进程执行，str1[1024]开始被写入管道。当写完一次后，说明此时管道中已经有数据可以供读取，此时唤醒读进程
 - 读进程虽然被唤醒，但是写进程还没有退出，所以写进程继续执行

```cpp
//尾指针用于读，头指针用于写
 fs --- pipe.c --- read_pipe() --- size=PIPE_SIZE(*inode)
                |               |  //size表示还有多少未读数据
                |               |- 若size=0表示全部读完，唤醒写进程，本进程休眠
                |               |- chars = PAGE_SIZE-PIPE_TAIL(*inode)
                |               |  //chars表示管道中还剩余的字节数
                |               |- if (chars > count)
                |               |      chars = count;
                |               |  //剩余字节数大于需读取的字节数
                |               |  //取需读取的字节数
                |               |- if (chars > size)
                |               |      chars = size;
                |               |  //要读的数据大于管道剩余未读的数据
                |               |  //取剩余未读数据
                |               |- count -= chars
                |               |- PIPE_TAIL(*inode) += chars
                |               |  //移动尾指针
                |               |- PIPE_TAIL(*inode) &= (PAGE_SIZE-1)
                |               |  //指针移动到4095以外，回滚到页首
                |               |- 拷贝内容到用户空间
                |               |- 唤醒写进程
                |- write_pipe() --- size=(PAGE_SIZE-1)-PIPE_SIZE(*inode) 
                                 |- //size表示管道中还有多少空间可供写入
                                 |- 若size=0表示管道中没有空间了，唤醒读进程，本进程休眠
                                 |- chars = PAGE_SIZE-PIPE_HEAD(*inode)
                                 |  //chars表示管道中还剩余的字节数
                                 |- if (chars > count)
                                 |      chars = count;
                                 |- if (chars > size)
                                 |      chars = size;
                                 |- count -= chars
                                 |- PIPE_HEAD(*inode) += chars
                                 |- PIPE_HEAD(*inode) &= (PAGE_SIZE-1)
                                 |- 将数据写入管道
                                 |- 唤醒读进程
```

 - 假设写管道的过程中发生了时钟中断，写进程的时间片会被削减，但是只要大于零，就不会退出。
 
```cpp
 kernel --- sched.c --- do_timer() --- if ((--current->counter)>0) return
                                    |- schedule()
```

 - 写进程一直写数据到管道中，直到管道写满，会挂起本进程，切换到读进程中执行

```cpp
 fs --- pipe.c --- read_pipe() --- size=PIPE_SIZE(*inode)
                                |- while(!size){
                                |       wake_up(&inode->i_wait);
                                |       sleep_on(&inode->i_wait);
                                |  }
```

 - 读进程执行，读出一次管道数据后，管道中有空间可供写入，唤醒写进程
 - 写进程虽被唤醒，但是读进程还没发生调度，因此读进程继续读取数据。
 - 假设期间发送时钟中断，会削减读进程时间片，时间片削减为0后切换到写进程中执行。
 - 写进程的尾指针调度之前指向4095的位置，此时唤醒后仍然为4095，进入下一次循环，由于尾指针的位置变了，因此size不为0，chars=1, HEAD=4096, 此时与上4095，HEAD=0, 回滚到页首，重新开始写入。
 - 写进程一直写数据，直到管道再次被写满，重新挂起，切换到读进程。
 - 此时读进程时间片为0，因此，进入schedule()函数后会重新分配时间片。

```cpp
 --- kernel --- sched.c --- schedule() --- for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
                                        |       if (*p)
                                        |           (*p)->counter = ((*p)->counter >> 1) +
                                        |               (*p)->priority;
```

 - 读进程继续执行，直到头指针和尾指针重合，再次切换到写进程。
 - 写进程和读进程轮流执行，直到数据交互完毕。
 