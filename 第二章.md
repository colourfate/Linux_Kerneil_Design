## 设备环境初始化及激活进程0
#### 1. 设置根设备、硬盘
```cpp
/*init/main.c
 --------------------------------------------------------------- */
#define DRIVE_INFO (*(struct drive_info *)0x90080)
#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)
...
void main(void)		/* This really IS void, no error here. */
{
	ROOT_DEV = ORIG_ROOT_DEV;
	drive_info = DRIVE_INFO;
    ...
}
```
setup.s通过BIOS中断将一些机器数据保存到了内存0x90000以后的地址，以覆盖bootsect.s。这里取出了其中的硬盘参数和根设备号。

#### 2. 设置缓冲区、虚拟盘、主内存在物理内存中的位置
```cpp
/* init/main.c
 --------------------------------------------------------------- */
#define EXT_MEM_K (*(unsigned short *)0x90002)
...
void main(void)		/* This really IS void, no error here. */
{
	...
    // 内存大小=1Mb + 扩展内存(k)*1024 byte
	memory_end = (1<<20) + (EXT_MEM_K<<10);
	memory_end &= 0xfffff000;
	if (memory_end > 16*1024*1024)
		memory_end = 16*1024*1024;
	if (memory_end > 12*1024*1024)
		buffer_memory_end = 4*1024*1024;
	else if (memory_end > 6*1024*1024)
		buffer_memory_end = 2*1024*1024;
	else
		buffer_memory_end = 1*1024*1024;
	main_memory_start = buffer_memory_end;
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
#endif
    ...
}
```
这里内存大小为16MB，缓冲区大小为4MB位于`0~0x3FFFFF`，虚拟盘为2MB位于`0x400000~0x5FFFFF`，主内存为10MB位于`0x600000~0xFFFFFF`。

#### 3. 初始化虚拟盘
```cpp
/* init/main.c
 --------------------------------------------------------------- */
#define EXT_MEM_K (*(unsigned short *)0x90002)
...
void main(void)		/* This really IS void, no error here. */
{
	...
	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
    ...
}

/* kernel/blk_drv/ll_rw_blk.c
 --------------------------------------------------------------- */
struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
	{ NULL, NULL },		/* no_dev */
	{ NULL, NULL },		/* dev mem */
	{ NULL, NULL },		/* dev fd */
	{ NULL, NULL },		/* dev hd */
	{ NULL, NULL },		/* dev ttyx */
	{ NULL, NULL },		/* dev tty */
	{ NULL, NULL }		/* dev lp */
};

/* kernel/ramdisk.c
 --------------------------------------------------------------- */
long rd_init(long mem_start, int length)
{
	int	i;
	char	*cp;

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
	rd_start = (char *) mem_start;
	rd_length = length;
	cp = rd_start;
	/* 将虚拟磁盘区清零 */
	for (i=0; i < length; i++)
		*cp++ = '\0';
	return(length);
}
```
这里`MAJOR_NR=1`，表示内存设备，将对应的`blk_dev[1].request_fn = DEVICE_REQUEST`，其中`DEVICE_REQUEST=do_rd_request`。然后将虚拟磁盘区清零。

#### 3. 内存管理结构mem_map初始化
系统通过mem_map[]对1MB以上的内存进行分页管理（一页为4KB），记录每一页的使用次数。初始化完成后`0~1MB`的页面被标记为`USED`，`1~16MB`的页面被清零，表示没有使用
```cpp
/* init/main.c
 --------------------------------------------------------------- */
#define EXT_MEM_K (*(unsigned short *)0x90002)
...
void main(void)		/* This really IS void, no error here. */
{
	...
	mem_init(main_memory_start,memory_end);
    ...
}

/* kernel/blk_drv/ll_rw_blk.c
 --------------------------------------------------------------- */

#define LOW_MEM 0x100000					// 内存低端(1MB)
#define PAGING_MEMORY (15*1024*1024)		// 分页内存15 MB，主内存区最多15M.
#define PAGING_PAGES (PAGING_MEMORY>>12)	// 分页后的物理内存页面数（3840）
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)	// 指定地址映射为页号
#define USED 100							// 页面被占用标志.
void mem_init(long start_mem, long end_mem)
{
	int i;
    // 1. 首先将16MB所有内存页面对应的内存映射字节数组项置为已占用状态
	HIGH_MEMORY = end_mem;                  // 设置内存最高端(16MB)
	for (i=0 ; i<PAGING_PAGES ; i++)
		mem_map[i] = USED;

	i = MAP_NR(start_mem);      // 主内存区其实位置处页面号
	end_mem -= start_mem;
	end_mem >>= 12;             // 主内存区中的总页面数
    // 2. 主内存区页面对应字节值清零
	while (end_mem-->0)
		mem_map[i++]=0;
	/* 3. 最后0~1MB的页面被标记为USED，1~16MB的页面被清零，表示没有使用 */
}
```

#### 4. 异常处理类中断服务程序挂接
首先设置`0~16`号中断，然后将`17~47`号中断设置为保留
```cpp
/* init/main.c
 --------------------------------------------------------------- */
...
void main(void)		/* This really IS void, no error here. */
{
	...
	trap_init();
    ...
}

/* kernel/traps.c
 --------------------------------------------------------------- */
void trap_init(void)
{
	int i;

	set_trap_gate(0,&divide_error);
	set_trap_gate(1,&debug);
    ...
}

#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \	// eax=0x00080000 | divide_error低16位
	"movw %0,%%dx\n\t" \	// edx=divide_error高16位 | 0x8000+(dpl<<13)+(type<<8)
							// edx:eax构成了中断描述符
	"movl %%eax,%1\n\t" \					// eax给低4字节地址
	"movl %%edx,%2" \						// edx给高4字节地址
	: \
	: "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \		// 输入的第0个参数
	"o" (*((char *) (gate_addr))), \   // 第1个参数，中断描述符的低4字节地址
	"o" (*(4+(char *) (gate_addr))), \ // 第2个参数，中断描述符的高4字节地址
	"d" ((char *) (addr)),"a" (0x00080000))	// "d"对应edx，"a"对应eax

#define set_trap_gate(n,addr) \
	_set_gate(&idt[n],15,0,addr)
```
这里设置ISR的方法是通过`&idt[n]`找到对应的中断描述符，然后将ISR地址写入其中。

#### 5. 初始化块设备请求项结构
