## 从开机加电到执行main函数之前的过程
#### 1. 启动BIOS，准备实模式下的中断向量表和中断服务程序
 - 按下电源键，处理器（IA-32）进入16位实模式，从`CS:IP=0xFFFF0`处开始运行。
 - BIOS程序在主板的一块ROM芯片中，该芯片无需初始化即可直接读取，被接在处理器的`0xFE000-0xFFFFF`地址处。
 - BIOS程序的入口地址被设计为`0xFFFF0`，因此上电过后处理器实际上运行的是BIOS程序。
 - BIOS程序将中断向量表放在内存的`0x00000`处，长度为1KB（256个中断，每个中断向量为4B），在0x00400处放BIOS数据区，长度为256B，在0x0E05B的处放中断服务程序，大小约8KB。

#### 2. 加载操作系统内核程序并为保护模式做准备
 - BIOS触发`int 0x19`中断，在中断向量表中查询到该中断服务程序的地址为`0x0E6F2`，处理器跳转到此处执行。
 - 该中断服务程序将读取软盘第一个扇区（512B）的数据到内存`0x07C00`处，这个扇区中的程序由bootsect.s文件编译生成，这是Linux 0.11的第一个程序。
 - 退出中断后，处理器跳回BIOS程序段，BIOS再将CS=0, IP=0x07C0，这样就可以跳转到`0x07C00`处执行。
 - bootsect.s程序第一件事是拷贝`0x07C00`开始的内容到`0x90000`处，长度为512B，即: 将bootsect.s自身移动到0x90000处。这一步目的是按照自己的需求安排内存。
```	x86asm
	mov	ax,#BOOTSEG
	mov	ds,ax			; ds=0x07C0
	mov	ax,#INITSEG
	mov	es,ax			; es=0x9000
	mov	cx,#256			; 循环次数256次
	sub	si,si			; si=0x0000
	sub	di,di			; di=0x0000
	rep
	movw				; 一次mov一个字，ds:si-->es:di
```
 - 拷贝完成后，CS=0x9000，处理器跳转到CS:IP处执行。这里巧妙利用了`jmpi`指令。
```	x86asm
jmpi	go,INITSEG	; jmpi 为段间跳转指令，即跳转到go标号处，然后将cs=INITSEG
go:	
	mov	ax,cs
```
 - 将DS, ES, SS都设置为0x9000，SP设置为0xFF00，此时栈地址为`SS:SP=0x9FF00`。设置栈地址后就可以使用PUSH和POP指令了。
```	x86asm
go: 
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
! put stack at 0x9ff00.
	mov	ss,ax
	mov	sp,#0xFF00		! arbitrary value >>512
```
 - 将软盘中第二个扇区开始的4个扇区(setup.s)拷贝到`0x90200`中，刚好紧挨bootsect的结尾。该拷贝使用int 0x13中断完成。
```	x86asm
load_setup:
	mov	dx,#0x0000		! drive 0, head 0
	mov	cx,#0x0002		! sector 2, track 0
	mov	bx,#0x0200		! address = 512, in INITSEG
	mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors
	int	0x13			! read it
	jnc	ok_load_setup		! ok - continue
	mov	dx,#0x0000
	mov	ax,#0x0000		! reset the diskette
	int	0x13
	j	load_setup
```
 - 将软盘中第六个扇区开始的240个扇区拷贝到`0x10000`往后的120KB的空间中。该拷贝过程与第二扇区的拷贝基本相同。
 - 确认根设备号，并跳转到0x90200(setup.s)中执行。跳转仍然使用`jmpi`指令
```	x86asm
seg cs
	mov	ax,root_dev
	cmp	ax,#0
	jne	root_defined
	seg cs
	mov	bx,sectors
	mov	ax,#0x0208		! /dev/ps0 - 1.2Mb
	cmp	bx,#15
	je	root_defined
	mov	ax,#0x021c		! /dev/PS0 - 1.44Mb
	cmp	bx,#18
	je	root_defined
undef_root:
	jmp undef_root
root_defined:
	seg cs
	mov	root_dev,ax
; 跳转到0x90200，即setup.s
	jmpi	0,SETUPSEG
```
 - setup.s开始，利用BIOS提供的中断服务程序将一些机器系统数据存放到`0x90000-0x901FD`处，共占510B，刚好将bootsect.s程序覆盖，bootsect不再使用。以下省略了大部分代码。
```	x86asm
start:
	; 保存光标位置
	mov	ax,#INITSEG	! this is done in bootsect already, but...
	mov	ds,ax
	mov	ah,#0x03	! read cursor pos
	xor	bh,bh
	int	0x10		! save it in known place, con_init fetches
	mov	[0],dx		! it from 0x90000.
	; 保存外接内存大小
	mov	ah,#0x88
	int	0x15
	mov	[2],ax
    ...
```

#### 3. 开始向32位模式转变，为main函数的调用做准备